<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sort</title>
      <link href="/2022/09/16/Sort/"/>
      <url>/2022/09/16/Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="1-排序的概念及其运用"><a href="#1-排序的概念及其运用" class="headerlink" title="1.排序的概念及其运用"></a>1.排序的概念及其运用</h2><h3 id="1-1排序的概念"><a href="#1-1排序的概念" class="headerlink" title="1.1排序的概念"></a>1.1排序的概念</h3><ul><li>排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</li><li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，<font color='red'>而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的 text </font>；否则称为不稳定的。</li><li>内部排序：数据元素全部放在内存中的排序。</li><li>外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</li></ul><h3 id="1-2-常见的排序算法"><a href="#1-2-常见的排序算法" class="headerlink" title="1.2 常见的排序算法"></a>1.2 常见的排序算法</h3><p><a href="https://imgse.com/i/vzhzr9"><img src="https://s1.ax1x.com/2022/09/16/vzhzr9.png" alt="排序归类" border="0" /></a>   </p><p>其中基数排序是比较特殊的一类，它是分类拆开后按顺序合并，以此类推，反复几次。</p><h2 id="2-常见排序算法的实现"><a href="#2-常见排序算法的实现" class="headerlink" title="2.常见排序算法的实现"></a>2.常见排序算法的实现</h2><h3 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h3><h4 id="2-1-1基本思想："><a href="#2-1-1基本思想：" class="headerlink" title="2.1.1基本思想："></a>2.1.1基本思想：</h4><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。实际中我们玩扑克牌时，就用了插入排序的思想。</p><p><a href="https://imgse.com/i/vz4LdI"><img src="https://s1.ax1x.com/2022/09/16/vz4LdI.jpg" alt="扑克牌示例" border="0" /></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; n - 1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">// [0,end]有序，把end+1位置的值插入，保持有序</span><br><span class="line">int end = i;</span><br><span class="line">int tmp = a[end + 1];</span><br><span class="line">while (end &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">if (tmp &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">a[end + 1] = a[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[end + 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2直接插入排序："><a href="#2-1-2直接插入排序：" class="headerlink" title="2.1.2直接插入排序："></a>2.1.2直接插入排序：</h4><p>当插入第i(i&gt;&#x3D;1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。<br>直接插入排序的特性总结：</p><ol><li>元素集合越接近有序，直接插入排序算法的时间效率越高</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)，它是一种稳定的排序算法</li><li>稳定性：稳定</li></ol><h3 id="2-1-3-希尔排序-缩小增量排序"><a href="#2-1-3-希尔排序-缩小增量排序" class="headerlink" title="2.1.3 希尔排序( 缩小增量排序 )"></a>2.1.3 希尔排序( 缩小增量排序 )</h3><p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取重复上述分组和排序的工<br>作。当到达&#x3D;1时，所有记录在统一组内排好序。</p><p><a href="https://imgse.com/i/vzIFje"><img src="https://s1.ax1x.com/2022/09/16/vzIFje.png" alt="希尔排序示例图" border="0" /></a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//平均：O(N^1.3）</span><br><span class="line">void ShellSort(int* a,int n)</span><br><span class="line">&#123;</span><br><span class="line">  int gap = n;</span><br><span class="line">  while(gap &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    gap = gap / 3 + 1;</span><br><span class="line">    for(int i=0;i&lt;n-gap;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      int end = i;</span><br><span class="line">      int temp = a[end + gap];</span><br><span class="line">      while(end &gt;= 0)</span><br><span class="line">      &#123;</span><br><span class="line">        if(temp &lt; a[end]&gt;)</span><br><span class="line">        &#123;</span><br><span class="line">          a[end + gap] = a[end];</span><br><span class="line">          end = end - gap;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      a[end + gap] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序的特性总结：</p><ol><li>希尔排序是对直接插入排序的优化。</li><li>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap &#x3D;&#x3D; 1时，数组已经接近有序的了，这样就<br>会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</li><li>希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算。</li></ol><h2 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h2><h3 id="2-2-1基本思想："><a href="#2-2-1基本思想：" class="headerlink" title="2.2.1基本思想："></a>2.2.1基本思想：</h3><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的<br>数据元素排完 。</p><h3 id="2-2-2-直接选择排序"><a href="#2-2-2-直接选择排序" class="headerlink" title="2.2.2 直接选择排序:"></a>2.2.2 直接选择排序:</h3><p>在元素集合array[i]–array[n-1]中选择关键码最大(小)的数据元素<br>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换在剩余的array[i]–array[n-2]（array[i+1]–array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void SelectSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">assert(a);</span><br><span class="line">int begin = 0, end = n - 1;</span><br><span class="line">while (begin &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">int mini = begin, maxi = begin;</span><br><span class="line">for (int i = begin + 1; i &lt;= end; ++i)</span><br><span class="line">&#123;</span><br><span class="line">if (a[i] &lt; a[mini])</span><br><span class="line">mini = i;</span><br><span class="line"></span><br><span class="line">if (a[i] &gt; a[maxi])</span><br><span class="line">maxi = i;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;a[begin], &amp;a[mini]);</span><br><span class="line"></span><br><span class="line">    //如果begin和maxi重叠，那么要修正一下maxi的位置</span><br><span class="line">    //即就是begin的位置就是最大值的位置，但之前begin位置的值已经和mini交换了，所以要把maxi再换回成mini的位置的值。</span><br><span class="line">if (begin == maxi)</span><br><span class="line">&#123;</span><br><span class="line">maxi = mini;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(&amp;a[end], &amp;a[maxi]);</span><br><span class="line">++begin;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接选择排序的特性总结：</p><ol><li>直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ol><h2 id="2-3-交换排序"><a href="#2-3-交换排序" class="headerlink" title="2.3 交换排序"></a>2.3 交换排序</h2><p>基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p><h3 id="2-3-1冒泡排序"><a href="#2-3-1冒泡排序" class="headerlink" title="2.3.1冒泡排序"></a>2.3.1冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int* a, int n)</span><br><span class="line">&#123;</span><br><span class="line">assert(a);</span><br><span class="line"></span><br><span class="line">for (int j = 0; j &lt; n - 1; ++j)</span><br><span class="line">&#123;</span><br><span class="line">int exchange = 0;</span><br><span class="line">for (int i = 1; i &lt; n - j; ++i)</span><br><span class="line">&#123;</span><br><span class="line">if (a[i - 1] &gt; a[i])</span><br><span class="line">&#123;</span><br><span class="line">Swap(&amp;a[i - 1], &amp;a[i]);</span><br><span class="line">exchange = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (exchange == 0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的特性总结：</p><ol><li>冒泡排序是一种非常容易理解的排序</li><li>时间复杂度：O(N^2) </li><li>空间复杂度：O(1)</li><li>稳定性：稳定</li></ol><h3 id="2-3-2-快速排序"><a href="#2-3-2-快速排序" class="headerlink" title="2.3.2 快速排序"></a>2.3.2 快速排序</h3><p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。  </p><ol><li><p>hoare版本<br>传统的右边先走，找大；左边先走，找小。顺序不能写反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int PartSort1(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">int left = begin, right = end;</span><br><span class="line">int keyi = left;</span><br><span class="line">while (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">// 右边先走，找小</span><br><span class="line">        //注意这里一定加上等于，如果不加等于号，</span><br><span class="line">//那么当左右两边数值相等时，就会死循环，因为交换之后两个数依旧是相等的。</span><br><span class="line"></span><br><span class="line">while (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">--right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左边再走，找大</span><br><span class="line">while (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">&#123;</span><br><span class="line">++left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;a[keyi], &amp;a[left]);</span><br><span class="line">keyi = left;</span><br><span class="line">return keyi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上left&lt;right的判断，否则可能会越界访问，因为当等于的情况下<br>还是有right–与left++，当key为最小值时，那么right向左移动直到<br>与key相等，此时是数组最左边，那么经过right–，就会越界。再循环中要加上，left&lt;right的判断。   </p></li><li><p>挖坑法<br>先将第一个数据存放在临时变量key中，形成一个坑位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int PartSort2(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">int key = a[begin];</span><br><span class="line">int pitI = begin;</span><br><span class="line">while (begin &lt; end)</span><br><span class="line">&#123;</span><br><span class="line">//右边找小，填左边的坑.</span><br><span class="line">while (begin &lt; end &amp;&amp; a[end] &gt;= key)</span><br><span class="line">&#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">a[pitI] = a[end];</span><br><span class="line">pitI = end;</span><br><span class="line">while (begin &lt; end &amp;&amp; a[begin] &lt;= key)</span><br><span class="line">&#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line">a[pitI] = a[begin];</span><br><span class="line">pitI = begin;</span><br><span class="line">&#125;</span><br><span class="line">a[pitI] = key;</span><br><span class="line">return pitI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前后指针版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int PartSort3(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">int prev = begin;</span><br><span class="line">int cur = begin + 1;</span><br><span class="line">int keyi = begin;</span><br><span class="line"></span><br><span class="line">// 加入三数取中的优化</span><br><span class="line">int midi = GetMidIndex(a, begin, end);</span><br><span class="line">Swap(&amp;a[keyi], &amp;a[midi]);</span><br><span class="line"></span><br><span class="line">while (cur &lt;= end)</span><br><span class="line">&#123; </span><br><span class="line">// cur位置的值小于keyi位置值</span><br><span class="line">if (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)</span><br><span class="line">Swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line"></span><br><span class="line">++cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Swap(&amp;a[prev], &amp;a[keyi]);</span><br><span class="line">keyi = prev;</span><br><span class="line"></span><br><span class="line">return keyi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetMidIndex(int* a, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">int mid = (begin + end) / 2;</span><br><span class="line">if (a[begin] &lt; a[mid])</span><br><span class="line">&#123;</span><br><span class="line">if (a[mid] &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">else if (a[begin] &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">return end;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return begin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-2-快速排序优化"><a href="#2-3-2-快速排序优化" class="headerlink" title="2.3.2 快速排序优化"></a>2.3.2 快速排序优化</h3><ol><li>三数取中法选key</li><li>递归到小的子区间时，可以考虑使用插入排序。C++的sort函数实现方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int* a, int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line">//当区间不存在或只有一个值</span><br><span class="line">if (begin &gt;= end)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (end - begin &gt; 10)</span><br><span class="line">&#123;</span><br><span class="line">int keyi = PartSort1(a, begin, end);</span><br><span class="line">QuickSort(a, begin, keyi - 1);</span><br><span class="line">QuickSort(a, keyi + 1, end);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">InsertSort(a + begin, end - begin + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-2-快速排序非递归"><a href="#2-3-2-快速排序非递归" class="headerlink" title="2.3.2 快速排序非递归"></a>2.3.2 快速排序非递归</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void QuickSortNonR(int* a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">Stack st;</span><br><span class="line">StackInit(&amp;st);</span><br><span class="line">StackPush(&amp;st, left);</span><br><span class="line">StackPush(&amp;st, right);</span><br><span class="line">while (StackEmpty(&amp;st) != 0)</span><br><span class="line">&#123;</span><br><span class="line"> right = StackTop(&amp;st);</span><br><span class="line"> StackPop(&amp;st);</span><br><span class="line"> left = StackTop(&amp;st);</span><br><span class="line"> StackPop(&amp;st);</span><br><span class="line"> </span><br><span class="line"> if(right - left &lt;= 1)</span><br><span class="line"> continue;</span><br><span class="line"> int div = PartSort1(a, left, right);</span><br><span class="line"> // 以基准值为分割点，形成左右两部分：[left, div) 和 [div+1, right)</span><br><span class="line"> StackPush(&amp;st, div+1);</span><br><span class="line"> StackPush(&amp;st, right);</span><br><span class="line"> </span><br><span class="line"> StackPush(&amp;st, left);</span><br><span class="line"> StackPush(&amp;st, div);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> StackDestroy(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的特性总结：</p><ol><li>快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序</li><li>时间复杂度：O(N*logN)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树(LeetCode练习题)</title>
      <link href="/2022/09/11/Binary%20tree%202/"/>
      <url>/2022/09/11/Binary%20tree%202/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树LeetCode联系（C语言）"><a href="#二叉树LeetCode联系（C语言）" class="headerlink" title="二叉树LeetCode联系（C语言）"></a>二叉树LeetCode联系（C语言）</h1><h2 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a>965. 单值二叉树</h2><p><a href="https://leetcode.cn/problems/univalued-binary-tree/">https://leetcode.cn/problems/univalued-binary-tree/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct TreeNode *left;</span><br><span class="line"> *     struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">bool isUnivalTree(struct TreeNode* root)&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val)</span><br><span class="line">    return false;</span><br><span class="line">    if(root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val)</span><br><span class="line">    return false;</span><br><span class="line">    return isUnivalTree(root-&gt;left)&amp;&amp;isUnivalTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>二叉树中的判断，以判错作为返回条件更清晰。当root&#x3D;&#x3D;NULL时返回真。</li><li>返回值中可以同时进行判断&amp;&amp;。</li></ul><hr><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p><a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool isSameTree(struct TreeNode* p, struct TreeNode* q)&#123;</span><br><span class="line">    if(p == NULL &amp;&amp; q == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(p == NULL &amp;&amp; q != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p != NULL &amp;&amp; q == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;val != q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!isSameTree(p-&gt;left,q-&gt;left)) </span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!isSameTree(p-&gt;right,q-&gt;right))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>清楚判错的所有条件，不要漏掉情况</li></ul><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool isCompare(struct TreeNode* p,struct TreeNode* q)</span><br><span class="line">&#123;</span><br><span class="line">    if(p == NULL &amp;&amp; q == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(p != NULL &amp;&amp; q == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if((p == NULL &amp;&amp; q != NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;left!=NULL &amp;&amp; q-&gt;right!=NULL &amp;&amp; p-&gt;left &amp;&amp; p-&gt;left-&gt;val != q-&gt;right-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;left == NULL &amp;&amp; q-&gt;right != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;right == NULL &amp;&amp; q-&gt;left != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;left != NULL &amp;&amp; q-&gt;right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p-&gt;right != NULL &amp;&amp; q-&gt;left == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isCompare(p-&gt;left,q-&gt;right) &amp;&amp; isCompare(p-&gt;right,q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSymmetric(struct TreeNode* root)&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isCompare(root,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(struct TreeNode* root)&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">        return 0;</span><br><span class="line">    int leftD = maxDepth(root-&gt;left);</span><br><span class="line">    int rightD = maxDepth(root-&gt;right);</span><br><span class="line">    return leftD &gt; rightD ? leftD+1 : rightD+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a>572. 另一棵树的子树</h2><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">bool Compare(struct TreeNode* root, struct TreeNode* subRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL &amp;&amp; subRoot == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root == NULL &amp;&amp; subRoot !=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root != NULL &amp;&amp; subRoot == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root != NULL &amp;&amp; subRoot != NULL &amp;&amp; root-&gt;val != subRoot-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return Compare(root-&gt;left,subRoot-&gt;left) &amp;&amp; Compare(root-&gt;right,subRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool SubtreeCompare(struct TreeNode* root, struct TreeNode* subRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root-&gt;val == subRoot-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        bool temp = Compare(root,subRoot);</span><br><span class="line">        if(temp == true)</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return SubtreeCompare(root-&gt;left,subRoot) || SubtreeCompare(root-&gt;right,subRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot)&#123;</span><br><span class="line">    if(subRoot == NULL)</span><br><span class="line">        return true;</span><br><span class="line">    //if(subRoot-&gt;val != root-&gt;val)</span><br><span class="line">    //    return false;</span><br><span class="line">    if(root == NULL &amp;&amp; subRoot != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return SubtreeCompare(root, subRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历</span><br><span class="line">void PreOrder(struct TreeNode* root, int *array, int* pi)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    array[(*pi)++] = root-&gt;val;</span><br><span class="line">    PreOrder(root-&gt;left,array,pi);</span><br><span class="line">    PreOrder(root-&gt;right,array,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //得到数组的长度</span><br><span class="line"> int getLong(struct TreeNode* root)</span><br><span class="line"> &#123;</span><br><span class="line">     if(root == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     return getLong(root-&gt;left)+getLong(root-&gt;right) + 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123;</span><br><span class="line">    *returnSize = getLong(root);</span><br><span class="line">    int *array = (int*)malloc(*returnSize * sizeof(int));</span><br><span class="line">    int i = 0;</span><br><span class="line">    PreOrder(root,array,&amp;i);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种在遍历的递归中有数组存在的，对数组的下标值访问，必须以指针地址的方式访问。才能保证每次都是在原来的基础上加一，如果不用指针，就会发生修改局部变量i，而没有修改上层中的i值。发生访问错误。</li></ul><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历</span><br><span class="line">void InOrder(struct TreeNode* root,int* array,int* pi)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrder(root-&gt;left,array,pi);</span><br><span class="line">    array[(*pi)++] = root-&gt;val;</span><br><span class="line">    InOrder(root-&gt;right,array,pi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //得到节点个数</span><br><span class="line"> int getLong(struct TreeNode* root)</span><br><span class="line"> &#123;</span><br><span class="line">     if(root == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     return getLong(root-&gt;left)+getLong(root-&gt;right)+1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">int* inorderTraversal(struct TreeNode* root, int* returnSize)&#123;</span><br><span class="line">    *returnSize = getLong(root);</span><br><span class="line">    int* array = (int*)malloc(sizeof(int) * *returnSize);</span><br><span class="line">    int i = 0;</span><br><span class="line">    InOrder(root,array,&amp;i);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//后序遍历</span><br><span class="line">void PostOrder(struct TreeNode* root,int* array,int* pi)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    PostOrder(root-&gt;left,array,pi);</span><br><span class="line">    PostOrder(root-&gt;right,array,pi);</span><br><span class="line">    array[(*pi)++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//得到节点个数</span><br><span class="line">int getLong(struct TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getLong(root-&gt;left) + getLong(root-&gt;right) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* postorderTraversal(struct TreeNode* root, int* returnSize)&#123;</span><br><span class="line">    *returnSize = getLong(root);</span><br><span class="line">    int* array = (int*)malloc(sizeof(int) * *returnSize);</span><br><span class="line">    int i = 0;</span><br><span class="line">    PostOrder(root,array,&amp;i);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get计算机硕士学位</title>
      <link href="/2022/09/10/Postgraduate%20studies/"/>
      <url>/2022/09/10/Postgraduate%20studies/</url>
      
        <content type="html"><![CDATA[<h1 id="Get计算机硕士学位"><a href="#Get计算机硕士学位" class="headerlink" title="Get计算机硕士学位"></a>Get计算机硕士学位</h1><h2 id="申请硕士学位全流程"><a href="#申请硕士学位全流程" class="headerlink" title="申请硕士学位全流程"></a>申请硕士学位全流程</h2><hr><br><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/全流程.286e1osdr5a8.webp"  width="70%"/></div><h2 id="申请硕士学位各环节具体要求"><a href="#申请硕士学位各环节具体要求" class="headerlink" title="申请硕士学位各环节具体要求"></a>申请硕士学位各环节具体要求</h2><h3 id="1-申请学位"><a href="#1-申请学位" class="headerlink" title="1.申请学位"></a>1.申请学位</h3><p>学分修够，开题通过，中期检查通过。</p><h3 id="2-欲答辩"><a href="#2-欲答辩" class="headerlink" title="2.欲答辩"></a>2.欲答辩</h3><p>第六学期</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910143620.1wbxxlgkvv28.webp"  width="70%"/></div><h3 id="3-送审前相似性检测"><a href="#3-送审前相似性检测" class="headerlink" title="3.送审前相似性检测"></a>3.送审前相似性检测</h3><p>预答辩后3天（3月底），先导师，后研究生院知网。小于15%，通过。大于50%推迟一年。</p><h3 id="4-学院送审"><a href="#4-学院送审" class="headerlink" title="4.学院送审"></a>4.学院送审</h3><p>外校送审，20天左右。2位外校老师。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910144047.5mie1278n300.webp"  width="70%"/></div><h3 id="5-答辩资格审核"><a href="#5-答辩资格审核" class="headerlink" title="5.答辩资格审核"></a>5.答辩资格审核</h3><p>学院送审和学校筹建均合格（5月底）</p><h3 id="6-答辩"><a href="#6-答辩" class="headerlink" title="6.答辩"></a>6.答辩</h3><p>答辩委员会，校内外专家。分为毕业和授位</p><h3 id="7-答辩后相似性检测"><a href="#7-答辩后相似性检测" class="headerlink" title="7.答辩后相似性检测"></a>7.答辩后相似性检测</h3><p>答辩后5天（6月初）提交正式论文。<br>知网检测。复制比小于15%。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910145123.5d1epvtoqtc0.webp"  width="70%"/></div><h3 id="8-学院教授委员会审议"><a href="#8-学院教授委员会审议" class="headerlink" title="8.学院教授委员会审议"></a>8.学院教授委员会审议</h3><p>政治思想，课程成绩，学术成果。做出是否建议周瑜硕士学位的决定。</p><h3 id="9-校教授委员会审议"><a href="#9-校教授委员会审议" class="headerlink" title="9.校教授委员会审议"></a>9.校教授委员会审议</h3><p>决定是否授予学位。</p><h2 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ul><li>1.学校查重过高。</li><li>2.在别的平台查重，结果和在学校的查重结果较大。</li><li>3.确保上传的论文位终稿。</li><li>4.不满足学校及各单位的科研成果的要求。</li><li>5.发表的小论文不符合学校要求（假刊，增刊，电子刊等）。</li><li>6.小论文存在学术不端（抄袭，雷同）。</li><li>7.关键信息错误。</li><li>8.暂缓发放毕业证或学位证。<div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910144437.1fapikfutzj4.webp"  width="70%"/><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910144235.10n8ja6j8to0.webp"  width="70%"/><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/QQ截图20220910144541.3913e29m46c0.webp"  width="70%"/></div></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会议 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer模型</title>
      <link href="/2022/09/07/Transformer/"/>
      <url>/2022/09/07/Transformer/</url>
      
        <content type="html"><![CDATA[<h2 id="输入部分"><a href="#输入部分" class="headerlink" title="输入部分"></a>输入部分</h2><h3 id="1-Embedding"><a href="#1-Embedding" class="headerlink" title="1. Embedding"></a>1. Embedding</h3><p>输入可以按字切分，对于翻译而言，可以把字切分成字向量。 </p><h3 id="2-位置嵌入"><a href="#2-位置嵌入" class="headerlink" title="2. 位置嵌入"></a>2. 位置嵌入</h3><p>RNN在处理翻译时，是一个一个输入，前一个处理结束后才进行下一个的处理，具备先后时序关系。而RTN是一起处理的，这就导致RTN处理前需要位置编码，告知处理或翻译中字的先后关系。举个例子，若没有位置编码，无法保证在“我爱你”翻译过程中，“我”在“你”的前面。</p><ul><li>位置编码公式如下：<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image.1nr5qo7msdb4.webp" alt="公式"> </li><li>2i即偶数位，2i+1即奇数位。<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(1).2705d9v11cu8.webp" alt="示例图"></li></ul><h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>注意力机制Attention就是权重。</p><h3 id="1-Encoder-Decoder模型"><a href="#1-Encoder-Decoder模型" class="headerlink" title="1. Encoder-Decoder模型"></a>1. Encoder-Decoder模型</h3><p>Encoder-Decoder模型就是RNN模型的变体。把整体对一句话编码，再进行机器翻译，这种无论输入多长，一起翻译的模型，导致翻译精度下降。<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(2).73yo6kne9mk0.webp" alt="RNN模型"></p><h3 id="2-Attention模型"><a href="#2-Attention模型" class="headerlink" title="2. Attention模型"></a>2. Attention模型</h3><p>Attention机制通过每个时间输入不同的C，来解决眉毛胡子一把抓的问题。其中α表明了在t时刻所有输入的权重。当前时刻以C1的视角往下看，就是每个输入不同输入的注意力（Attention分布）。经过神经网络数据训练，就可以得到最好的Attention权重矩阵。<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(3).4r8uil0s2ro0.webp" alt="Attention模型"></p><h3 id="3-Self-Attention"><a href="#3-Self-Attention" class="headerlink" title="3. Self-Attention"></a>3. Self-Attention</h3><p>因为在Attention机制中已经是完成对所有的输入全局评判，因此对于输入顺序已经不重要。比如在一句话的翻译中，Attention机制会计算每个单词与其他单词之间的关联。利用这些权重加权表示，再放到神经网络中，就很好的得到了上下文的信息。<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(4).41ueuk04f3q0.webp" alt="Self-Attention"><br><br>把每个信息之间的联系多处理几次，得到的权重再次进行处理。得到的就是Self-Attention机制。<br><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(5).1hjqt24186m8.webp" alt="多重联系"><br><br>总结下来，Attention机制有三大优点。</p><ol><li>参数更少。</li><li>速度更快。</li><li>效果更好。想·</li></ol><p>核心思想就是通过加权求和，本质就是在不同的上下文中，专注不同的信息，因此无论是NLP，图像还是搜索，预测。使用Attention都有好的处理结果。</p><p><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(6).15298dmharts.webp" alt="应用图"></p><h2 id="解码编码"><a href="#解码编码" class="headerlink" title="解码编码"></a>解码编码</h2><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree</title>
      <link href="/2022/09/06/Binary%20tree/"/>
      <url>/2022/09/06/Binary%20tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树链式结构的实现"><a href="#二叉树链式结构的实现" class="headerlink" title="二叉树链式结构的实现"></a>二叉树链式结构的实现</h2><h3 id="1-定义二叉树"><a href="#1-定义二叉树" class="headerlink" title="1.定义二叉树"></a>1.定义二叉树</h3><p>（二叉树节点与节点存储的数据类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef char BTDataType;</span><br><span class="line"></span><br><span class="line">typedef struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">        BTDataType data;</span><br><span class="line">        struct BinaryTreeNode* _left;</span><br><span class="line">        struct BinaryTreeNode* _right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个存储字符数据类型的二叉树。可以直接在typedef修改二叉树中存储的数据类型，便于后期修改。</p><h3 id="2-创建（新建）节点"><a href="#2-创建（新建）节点" class="headerlink" title="2. 创建（新建）节点"></a>2. 创建（新建）节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BTNode* BuyNode(BTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">        BTNode* node = (BTNode*)malloc(sizeof(BTNode));</span><br><span class="line">        assert(node);</span><br><span class="line">        node-&gt;data = x;</span><br><span class="line">        node-&gt;_left = NULL;</span><br><span class="line">        node-&gt;_right = NULL;</span><br><span class="line">        return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认设置左右孩子为空。<br>使用assert检测node节点创建是否成功。若有错，系统会有提示，而不是直接崩溃。例如使用整数除以0，assert函数就会报错。</p><h3 id="3-创建（新建）二叉树"><a href="#3-创建（新建）二叉树" class="headerlink" title="3. 创建（新建）二叉树"></a>3. 创建（新建）二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BTNode* CreatBinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">        BTNode* node1 = BuyNode(&#x27;1&#x27;);</span><br><span class="line">        BTNode* node2 = BuyNode(&#x27;2&#x27;);</span><br><span class="line">        BTNode* node3 = BuyNode(&#x27;3&#x27;);</span><br><span class="line">        BTNode* node4 = BuyNode(&#x27;4&#x27;);</span><br><span class="line">        BTNode* node5 = BuyNode(&#x27;5&#x27;);</span><br><span class="line">        BTNode* node6 = BuyNode(&#x27;6&#x27;);</span><br><span class="line"></span><br><span class="line">        node1-&gt;_left = node2;</span><br><span class="line">        node1-&gt;_right = node3;</span><br><span class="line">        node2-&gt;_left = node4;</span><br><span class="line">        node2-&gt;_right = node5;</span><br><span class="line">        node3-&gt;_right = node6;</span><br><span class="line"></span><br><span class="line">        return node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建如图所示的二叉树模型。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(25).1wkpets31ubk.webp"  width="45%"/></div>  <h3 id="4-遍历二叉树"><a href="#4-遍历二叉树" class="headerlink" title="4. 遍历二叉树"></a>4. 遍历二叉树</h3><p>遍历二叉树，就是对二叉树的每个节点访问一次。并且需要满足某种特定的规则。主要分为前序，中序，后续遍历。<br>因此对于上图所表示的二叉树有以下遍历结果：   </p><table><thead><tr><th>Name</th><th align="right">score</th></tr></thead><tbody><tr><td>前序遍历</td><td align="right">1 2 4 # # 5 # # 3 # 6 # #</td></tr><tr><td>中序遍历</td><td align="right"># 4 # 2 # 5 # 1 # 3 # 6 #</td></tr><tr><td>后序遍历</td><td align="right"># # 4 # # 5 2 # # # 6 3 1</td></tr></tbody></table><h4 id="4-1-前序遍历"><a href="#4-1-前序遍历" class="headerlink" title="4.1 前序遍历"></a>4.1 前序遍历</h4><p>前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(26).2n6gqyw62pc0.webp"  width="45%"/></div> <ul><li>前序遍历，根，左子根，右子根。先1，后1的左孩子2,2的左孩子4,4的左孩子空，4的右孩子空，2的右孩子5,5的左右孩子均为空，1的右孩子3,3的左孩子空，3的右孩子6,6的左右孩子均为空。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void BinaryTreePrevOrder(BTNode* root)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;# &quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%c &quot;,root-&gt;data);</span><br><span class="line">        BinaryTreePrevOrder(root-&gt;_left);</span><br><span class="line">        BinaryTreePrevOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(29).1dsr0n5pyfvk.webp"  width="100%"/></div> <h4 id="4-2-中序遍历"><a href="#4-2-中序遍历" class="headerlink" title="4.2 中序遍历"></a>4.2 中序遍历</h4><ul><li>中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之间。</li></ul><p>中序遍历，左子根，根，右子根。先向左遍历找到，最左子根4的左孩子为空，再根4，4的右孩子为空，再根2，再2的右孩子5，再5的左孩子为空，在根5，再5的右孩子为空，再根1，再1的右子树根3，但3有左孩子，先访问3的左孩子空，再根3，再3的右子树根6，但6有左孩子，再6的左孩子为空，再根6，再6的右孩子为空。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(27).15zc94ev9a74.webp"  width="45%"/></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void BinaryTreeInOrder(BTNode* root)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;# &quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeInOrder(root-&gt;_left);</span><br><span class="line">        printf(&quot;%c &quot;, root-&gt;data);</span><br><span class="line">        BinaryTreeInOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(30).6emaycebxhk0.webp"  width="100%"/></div> <h4 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h4><ul><li>后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</li></ul><p>后序遍历，左子根，右子根，根。1的最左为4，先4的左孩子为空，再4的右孩子为空，再根4，再回溯到2,到2的右子树5，再访问5的左右孩子均为空。再回溯访问2，再回溯到1,1的右子树3,再访问3的左孩子为空，再回溯到2，2的右子树6，再访问6的左右孩子为空。再回溯访问6，再回溯访问到1。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(28).7769nyaj1d00.webp"  width="45%"/></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void BinaryTreePostOrder(BTNode* root)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;# &quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreePostOrder(root-&gt;_left);</span><br><span class="line">        BinaryTreePostOrder(root-&gt;_right);</span><br><span class="line">        printf(&quot;%c &quot;, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(31).2lztw4cs8xs0.webp"  width="100%"/></div> 三个运行结果和初期预测的执行结果相同。<h3 id="5-二叉树的简单统计"><a href="#5-二叉树的简单统计" class="headerlink" title="5. 二叉树的简单统计"></a>5. 二叉树的简单统计</h3><h4 id="5-1-二叉树节点个数"><a href="#5-1-二叉树节点个数" class="headerlink" title="5.1 二叉树节点个数"></a>5.1 二叉树节点个数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树节点个数</span><br><span class="line">int BinaryTreeSize(BTNode* root)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return BinaryTreeSize(root-&gt;_left) + BinaryTreeSize(root-&gt;_right) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-二叉树叶节点个数"><a href="#5-2-二叉树叶节点个数" class="headerlink" title="5.2 二叉树叶节点个数"></a>5.2 二叉树叶节点个数</h4><p>一个特别需要注意的点：<font color=red>在二叉树的递归，进入循环的第一步一定要先判断节点是否为空</font>。对于下面的代码而言，若是先判断左右孩子是否为空再判断节点为空，程序就会崩溃。因为会出现当程序访问了空节点时还要判断该空节点的左右孩子是否为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int BinaryTreeLeafSize(BTNode* root)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">                return 0;</span><br><span class="line">        if (root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return BinaryTreeLeafSize(root-&gt;_left) + BinaryTreeLeafSize(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(33).5z4b45ssy280.webp"  width="100%"/></div><h4 id="5-3-二叉树查找值为x的节点"><a href="#5-3-二叉树查找值为x的节点" class="headerlink" title="5.3 二叉树查找值为x的节点"></a>5.3 二叉树查找值为x的节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BTNode* BinaryTreeFind(BTNode* root, BTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x == root-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;已找到数值为%c的节点&quot;, x);</span><br><span class="line">                return root;</span><br><span class="line">        &#125;</span><br><span class="line">        BTNode* leftRet = BinaryTreeFind(root-&gt;_left, x);</span><br><span class="line">        if (leftRet)</span><br><span class="line">        &#123;</span><br><span class="line">                return leftRet;</span><br><span class="line">        &#125;</span><br><span class="line">        BTNode* rightRet = BinaryTreeFind(root-&gt;_right, x);</span><br><span class="line">        if (rightRet)</span><br><span class="line">        &#123;</span><br><span class="line">                return rightRet;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(34).513bg8t4lwg0.webp"  width="100%"/></div>在二叉树中，对左右孩子的判断要紧接着递归结束就判断。若等左右递归完一起判断，有较大可能出错。<p>一个错误代码，下面的代码，只要是查找的数在左子树就能正确找到，右子树也会找到，但是会返回NULL。函数最后结束值不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BTNode* BinaryTreeFind(BTNode* root, BTDataType x)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x == root-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;已找到数值为%c的节点&quot;, x);</span><br><span class="line">                return root;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTreeFind(root-&gt;_left, x);</span><br><span class="line">        BinaryTreeFind(root-&gt;_right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-二叉树第K层节点个数"><a href="#5-4-二叉树第K层节点个数" class="headerlink" title="5.4 二叉树第K层节点个数"></a>5.4 二叉树第K层节点个数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int BinaryTreeLevelKSize(BTNode* root, int k)</span><br><span class="line">&#123;</span><br><span class="line">        if (root == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 1 )</span><br><span class="line">        &#123;</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return BinaryTreeLevelKSize(root-&gt;_left, k - 1) + BinaryTreeLevelKSize(root-&gt;_right, k - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(35).76xstjqy2s80.webp"  width="90%"/></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长短期记忆网络（LSTM）</title>
      <link href="/2022/09/06/STML/"/>
      <url>/2022/09/06/STML/</url>
      
        <content type="html"><![CDATA[<h1 id="长短期记忆-LSTM"><a href="#长短期记忆-LSTM" class="headerlink" title="长短期记忆-LSTM"></a>长短期记忆-LSTM</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>时间的长短期预测，包括股票预测，气象预测语音识别等。这个时候传统的循环神经网络RNN就捉襟见肘。它虽然建立了不同时刻隐藏层之间的关系。实现了记忆的效果，但只是基于前一时刻。</p><ul><li>RNN是一种短时记忆。</li><li>RNN是想把所有的信息都记住，无论是有用还是没用的信息。不具备筛选的功能。<div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(7).cmtksvb31gg.webp"  width="50%"/><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(8).ju9vfra8u80.webp" width="50%"/> </div></li></ul><h2 id="RNN传统循环神经网络模型"><a href="#RNN传统循环神经网络模型" class="headerlink" title="RNN传统循环神经网络模型"></a>RNN传统循环神经网络模型</h2><p>左边红球是不同时间的输入x,中间蓝色是隐藏状态s，右边绿球是网络输出y。在LSTM中增加新的时间线（粉色），同时增加与隐藏状态的联系。<br>因此，相比较RNN，在STLM中，计算当前时刻t的隐藏状态时，就需要输入x(t)，前一时刻s（t-1)，还需要包含当前时刻的信息c(t)。这就是相当于一个日记本（记忆细胞），记录当前时刻的信息。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(9).6kiyvgziryo.webp"  width="50%"/><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(10).2g03g19mq0w0.webp" width="50%"/> </div> 对右上图转换，s(t)与c(t)之间的联系关系被拆分成如下的f1,f2,与c(t)指向s(t)线，一共三条联系线。 <br>  <ul><li>f1被称作遗忘门，起到删除功能。它根据昨天记忆s(t-1)和今天输入x(t)，决定来修改删除之前记录c(t-1)。数学表示如下图。其中sigmoid函数取值0到1之间，矩阵元素向乘，会抹掉为0的项，相当于选择性遗忘部分信息。<br></li><li>f2被称作选择门，其增加选择功能。其中sigmoid函数对信息进行选择，tanh函数取值-1到1之间，起到对数据整理加归纳.<br></li><li>因此，得到c（t）&#x3D;f1*c(t-1)+f2。这个得到的c(t)不仅会继续向下传递，同时还会来更新当前短期记忆s(t)，即第三条关联线。<div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(11).5z5rn8f9ejs.webp"  width="30%"/><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(13).cb3raezz27k.webp" width="30%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(12).65waw4lqhec0.webp" width="30%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(16).2yk69gynmxa0.webp" width="40%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(14).41bi9k8jv2g0.webp" width="40%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(17).6ejn8w2i9yk0.webp" width="40%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(18).678cphnkm7s0.webp" width="40%"/> </div>经过以上操作，就可得到输出y（t）,同时保持并得到短期记忆链s与长期记忆链c。并且相互更新。</li></ul><h2 id="传统LSTM向前传播过程"><a href="#传统LSTM向前传播过程" class="headerlink" title="传统LSTM向前传播过程"></a>传统LSTM向前传播过程</h2><p>详细讲解LSTM中具体的细节实现。LSTM的详细传递模型图。<br>每一个绿色矩形中，都被成为一个记忆细胞。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image.5bgoyw79ji80.webp" width="80%"/> <img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(19).1gehkqruadi8.webp" width="30%"/>   </div><ul><li>σ就是sigmoid函数,也被称作门，取值在0到1之间。</li><li>下图中的g(t)就是c(t)。</li><li>得到c(t)之后，h(t)由c(t)向下经过tanh函数门，再与o(t)想乘。o(t)与f(t)相同，都是遗忘门。</li><li>h(t)即使当前输出状态（紫色的可直接输出），也是长时记忆链的当前状态。并持续向下传播。</li><li>y(t)就是输出，对应需要的格式。可灵活多变。<div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(20).2hkik6yigly0.webp" width="80%"/>   </div></li></ul><h2 id="LSTM的变体"><a href="#LSTM的变体" class="headerlink" title="LSTM的变体"></a>LSTM的变体</h2><h3 id="1-长时记忆影响"><a href="#1-长时记忆影响" class="headerlink" title="1. 长时记忆影响"></a>1. 长时记忆影响</h3><p>增加前一时刻长时记忆的影响，在遗忘门之前得到前一时刻的长期记忆c(t)。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(21).2dkydrfawlxc.webp" width="80%"/>   </div><h3 id="2-耦合遗忘门和输入门"><a href="#2-耦合遗忘门和输入门" class="headerlink" title="2. 耦合遗忘门和输入门"></a>2. 耦合遗忘门和输入门</h3><p>这种情况下，只有遗忘了旧的信息，才会添加新的信息。“1”减去矩阵中所要遗忘的，矩阵为1的项，减完后为0，进入更新门，此时需要遗忘部分为0，矩阵想乘时，就会丢弃掉这部分数据。（1-f(t))代表更新的结果，再加遗忘门数据。得到长时记忆输出C(T)。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(22).70n8gfo01ww0.webp" width="80%"/>   </div><h3 id="3-组合为更新门且合并长时记忆"><a href="#3-组合为更新门且合并长时记忆" class="headerlink" title="3. 组合为更新门且合并长时记忆"></a>3. 组合为更新门且合并长时记忆</h3><p>整合长时和短期记忆，全部都需要依赖前一时刻的短期记忆。</p><div align=center><img  src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/image-(24).6n994o3w2qk0.webp" width="80%"/>   </div><hr><p>参考：<br><a href="https://www.bilibili.com/video/BV1qM4y1M7Nv?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1qM4y1M7Nv?spm_id_from=333.337.search-card.all.click</a><br><a href="https://www.bilibili.com/video/BV1Z34y1k7mc?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Z34y1k7mc?spm_id_from=333.337.search-card.all.click</a><br><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致毕业</title>
      <link href="/2022/09/06/hello-world/"/>
      <url>/2022/09/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>记录的是本科毕业致谢。</p><h2 id="毕业敬辞"><a href="#毕业敬辞" class="headerlink" title="毕业敬辞"></a>毕业敬辞</h2><center>骊山北麓，芷阳湖畔，屹此吾校，鳞次栉比，碧瓦朱甍，气贯长虹；</center> <center>何其所幸，拜学于此，星霜荏苒，方适四载，壬寅盛夏，迟迟吾行；</center> <center>前尘影事，良师诤友，温澜潮生，铭感五内，一夕千念，报本反始；</center>&ensp;&ensp;向四年矣，余自西城负箧至镐。歧路他乡，不求闻达内外之名，欲明上下求索之理。力学笃行，寻珠玑以拜读；穷文求理，究理法之无穷。然学术之道，高深莫测，吾力有不逮，久未参晓登堂入室之法。 <br>&ensp;&ensp;恩师王先生蒙也，温文尔雅，博通经籍。助余论文以润色，足获取良多。先生常嘱余学问之道乃求其上者得其中也。教吾于学须精益求精，切忌不求甚解。师之教诲，恰似春风细雨润禾以滋养之恩，亦如醍醐灌顶谓吾以造化之能。余常念师恩，于此未足尽言矣！ <br>&ensp;&ensp;吾师刘先生枫也，克己奉公，通才硕学。余每遇弗通事，欣然前往询其焉。师不厌其烦，循循善诱，授予以渔鱼双全之法。于其暇，常谈余近日学况，关切之意，不言而表。告谓余须晓本固枝荣之理，力据好高骛远之见。幸得师之箴言，获益匪浅，然感激之言，却只聊表一二。 <br>&ensp;&ensp;吾之同窗，如松，鸣，著，强。皆俊秀之才，上足之士，同志合道，先是宽我以错，容我微词，后则急我之难，助我其学。吾与诸公挟秋香以入太学，抱碧华而理丹铅。余得如此同砚，今朝别离，当天涯比邻。 <br>&ensp;&ensp;吾出寒门，非钟鸣鼎食之家。余自入学，母叮咛许许，勿忘枕典席文，以振门楣；父则夙兴夜寐，喜怒不言于声色，期儿以大展宏图。南山险峻，怎念家境寒薄难亲为；春来秋往，犹记不惑父母苦夕拾。然父母之恩，非南山可抵，苍山云海，吾唯静心学业，以期春华秋实。 <br>&ensp;&ensp;于则此，吾亦谢报我以艰者尔。公尔驱余获益吾所不能。 <br>&ensp;&ensp;凡此种种，顿首以谢。 <br>&ensp;&ensp;即日，壬寅佳岁，午月下旬。 <br><hr><h2 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h2><p><img src="https://cdn.staticaly.com/gh/xys176/image-hosting@master/%E8%87%B4%E8%B0%A2.dgczlrley28.webp" alt="致谢" title="致谢"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
